drop extension if exists "pg_net";

drop policy "Users can join rooms" on "public"."room_participants";

drop policy "Users can update their own participation" on "public"."room_participants";


  create table "public"."profile" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text,
    "avatar" text,
    "updated_at" timestamp with time zone default now(),
    "user_id" uuid
      );


alter table "public"."profile" enable row level security;

CREATE INDEX idx_profile_user_id ON public.profile USING btree (user_id);

CREATE UNIQUE INDEX profile_pkey ON public.profile USING btree (id);

CREATE UNIQUE INDEX profile_user_id_key ON public.profile USING btree (user_id);

alter table "public"."profile" add constraint "profile_pkey" PRIMARY KEY using index "profile_pkey";

alter table "public"."profile" add constraint "profile_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."profile" validate constraint "profile_user_id_fkey";

alter table "public"."profile" add constraint "profile_user_id_key" UNIQUE using index "profile_user_id_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.create_profile_on_auth_user_insert()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  INSERT INTO public.profile (user_id, name)
  VALUES (
    new.id, 
    new.raw_user_meta_data->>'name'
  );
  RETURN NEW;
END;
$function$
;

grant delete on table "public"."profile" to "anon";

grant insert on table "public"."profile" to "anon";

grant references on table "public"."profile" to "anon";

grant select on table "public"."profile" to "anon";

grant trigger on table "public"."profile" to "anon";

grant truncate on table "public"."profile" to "anon";

grant update on table "public"."profile" to "anon";

grant delete on table "public"."profile" to "authenticated";

grant insert on table "public"."profile" to "authenticated";

grant references on table "public"."profile" to "authenticated";

grant select on table "public"."profile" to "authenticated";

grant trigger on table "public"."profile" to "authenticated";

grant truncate on table "public"."profile" to "authenticated";

grant update on table "public"."profile" to "authenticated";

grant delete on table "public"."profile" to "service_role";

grant insert on table "public"."profile" to "service_role";

grant references on table "public"."profile" to "service_role";

grant select on table "public"."profile" to "service_role";

grant trigger on table "public"."profile" to "service_role";

grant truncate on table "public"."profile" to "service_role";

grant update on table "public"."profile" to "service_role";


  create policy "Enable users to view their own data only"
  on "public"."profile"
  as permissive
  for select
  to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Users can update own profile"
  on "public"."profile"
  as permissive
  for update
  to authenticated
using ((( SELECT auth.uid() AS uid) = user_id))
with check ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Enable insert for authenticated users only"
  on "public"."room_participants"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Users can insert into rooms"
  on "public"."room_participants"
  as permissive
  for update
  to authenticated
using (true)
with check (true);



  create policy "Enable delete for users based on user_id"
  on "public"."rooms"
  as permissive
  for delete
  to authenticated
using ((( SELECT auth.uid() AS uid) = created_by));


CREATE TRIGGER create_profile_after_signup AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION public.create_profile_on_auth_user_insert();


  create policy "avatar_objects_delete_owner_only"
  on "storage"."objects"
  as permissive
  for delete
  to authenticated
using (((bucket_id = 'avatar'::text) AND (owner_id = (( SELECT auth.uid() AS uid))::text)));



  create policy "avatar_objects_insert_authenticated"
  on "storage"."objects"
  as permissive
  for insert
  to authenticated
with check (((bucket_id = 'avatar'::text) AND (owner_id IS NOT NULL) AND (owner_id = (( SELECT auth.uid() AS uid))::text)));



  create policy "avatar_objects_select_authenticated"
  on "storage"."objects"
  as permissive
  for select
  to authenticated
using ((bucket_id = 'avatar'::text));



  create policy "avatar_objects_update_owner_only"
  on "storage"."objects"
  as permissive
  for update
  to authenticated
using (((bucket_id = 'avatar'::text) AND (owner_id = (( SELECT auth.uid() AS uid))::text)))
with check (((bucket_id = 'avatar'::text) AND (owner_id = (( SELECT auth.uid() AS uid))::text)));



  create policy "avatars_delete_own"
  on "storage"."objects"
  as permissive
  for delete
  to authenticated
using (((bucket_id = 'avatars'::text) AND (((owner_id IS NOT NULL) AND (owner_id = (auth.uid())::text)) OR ((owner IS NOT NULL) AND (owner = auth.uid())))));



  create policy "avatars_insert_any_authenticated"
  on "storage"."objects"
  as permissive
  for insert
  to authenticated
with check ((bucket_id = 'avatars'::text));



  create policy "avatars_update_own"
  on "storage"."objects"
  as permissive
  for update
  to authenticated
using (((bucket_id = 'avatars'::text) AND (((owner_id IS NOT NULL) AND (owner_id = (auth.uid())::text)) OR ((owner IS NOT NULL) AND (owner = auth.uid())))))
with check (((bucket_id = 'avatars'::text) AND (((owner_id IS NOT NULL) AND (owner_id = (auth.uid())::text)) OR ((owner IS NOT NULL) AND (owner = auth.uid()))) AND ((string_to_array(name, '/'::text))[1] = (auth.uid())::text)));



